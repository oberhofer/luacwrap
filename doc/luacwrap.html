<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>luacwrap</title>
	<link rel="stylesheet" type="text/css" href="lua.css" />
</head>
<body>

<p><img src="logo.png" alt="LuaCwrap logo" title="LuaCwrap logo"/></p>

<h1>Introduction</h1>

<p>LuaCwrap is a wrapper for C datatypes written in pure C. It utilizes metadata (aka type descriptors)
to describe the layout and names of structures, unions, arrays and buffers.</p>

<h2>Attention</h2>

<p>Because LuaCwrap allows to attach wrappers to existing userdata (pointers) it is not safe 
according to the Lua book. Common errors will be detected by LuaCwrap, but as the 'attach' 
method acts like a C cast many things could go wrong.
So if you use 'attach' be sure to know what you are doing.</p>

<h2>Features</h2>

<p>LuaCwrap</p>

<ul>
    <li>supports struct and union types</li>
    <li>supports array types</li>
    <li>supports fixed length buffers</li>
    <li>supports pointers</li>
    <li>lua strings and userdata could be assigned to wrapped pointers</li>
    <li>maintains lifetime of lua objects which had been assigned to wrapped pointers</li>
    <li>supports C and Lua API</li>
</ul>

<h1>Usage</h1>

<h2>Import LuaCwrap</h2>

<p>Importing LuaCwrap is only necessary if you want to declare your own types via the Lua-API.
In this case use the followig line:</p>

<div class="code">luacwrap = import("luacwrap")
</div>

<p>C modules which want to provide wrappers usually create their own namespace table to register their types. 
For an example see the source code of the <code>testluacwrap</code> module, which is provided with this package 
for unittesting.</p>

<h2>Registering type descriptors</h2>

<p>A valid registered type desriptor is necessary to create data type instances. 
In LuaCwrap you can register type descriptors via a Lua or a C API.</p>

<h3>Lua-API</h3>

<h4>Register array types</h4>

<div class="code">type = luacwrap.registerarraytype(name, size, elemtype)
</div>

<h4>Register record types</h4>

<div class="code">type = luacwrap.registerrecordtype(name, members)
</div>

<h4>Register buffer types</h4>

<div class="code">type, name = luacwrap.registerbuffertype(name, size)
</div>


<h3>C-API</h3>

<h4>Register array types</h4>

<div class="code">// describe array type
luacwrap_ArrayType regType_INT32_4 =
{
  LUACWRAP_TC_ARRAY,
  "INT32_4",
  4,
  sizeof(INT32),
  "$i32"
};

luacwrap_registertype(L, LUA_GLOBALSINDEX, &amp;regType_INT32_4.hdr);
</div>

<h4>Register record types</h4>

<div class="code">// member descriptor for INNERSTRUCT
static luacwrap_RecordMember s_memberINNERSTRUCT[] =
{
  { "pszText",  offsetof(INNERSTRUCT, pszText),  "$ptr" },
  { NULL, 0 }
};

// type descriptor for INNERSTRUCT
LUACWRAP_DEFINESTRUCT(LIBRARYNAME, INNERSTRUCT)

// register type within globals table
luacwrap_registertype(L, LUA_GLOBALSINDEX, &amp;regType_INNERSTRUCT.hdr);
</div>

<h4>Register buffer types</h4>

<div class="code">luacwrap_BasicType regType_Buf32 =
{
  LUACWRAP_TC_BUFFER,
  "$buf32",
  32
};

luacwrap_registerbasictype(L, &amp;regType_Buf32);
</div>

<h4>Register basic types</h4>

<p>For these types you have to specify appropriate get and set callbacks which handles
marshalling. Therefore registering basic types is only possible via the C API.
Use the <code>luacwrap_registerbasictype</code> function and see the source of LuaCwrap
for usage examples.</p>

<h2>Create/Attach instances</h2>

<h3>Lua-API</h3>

<p>Every registered type descriptor has two methods <code>new</code> and <code>attach</code> which could be used to
create new instances or create a wrapper around existing userdata.</p>

<h3>C-API</h3>


<h1>Internals</h1>

<h2>Module table _M</h2>

<p>LuaCwrap creates a single module table, where all module global data is stored.
The module table contains:</p>

<ul>
    <li>helper functions (e.g. tabletostring, getfield, setfield)</li>
    <li>register functions (registerbuffer, registerarray, registerstruct)</li>
    <li>buffer creation function (createbuffer)</li>
    <li>types table (_M.types)</li>
</ul>

<h2>Type descriptor table _M.types</h2>

<p>The type descriptor table spans the namespace for all registered types. Type names containing dots are
stored in the corresponding subtables.
The type table contains predefined types which names start with the '$' character. 
These are</p>

<ul>
    <li>$i8 , $u8  (signed/unsigned char)</li>
    <li>$i16, $u16 (signed/unsigned short)</li>
    <li>$i32, $u32 (signed/unsigned long)</li>
    <li>$flt, $dbl (float, double)</li>
    <li>$ptr       (pointer types)</li>
</ul>

<p>Buffers are registered within the type table, too. The name of buffer types is derived
from the buffer length ($buf*, where * denotes the buffer length).
If a buffer with the requested size is already registered, the existing one is returned.</p>

<h1>License</h1>

<p>LuaCwrap is licensed under the terms of the MIT license reproduced below.
This means that LuaCwrap is free software and can be used for both academic
and commercial purposes at absolutely no cost.</p>

<p>Copyright (C) 2011 Klaus Oberhofer</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</p>


</body></html>