<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>luacwrap</title>
	<link rel="stylesheet" type="text/css" href="lua.css" />
</head>
<body>

<p><img src="logo.png" alt="LuaCwrap logo" title="LuaCwrap logo"/></p>

<h1>Introduction</h1>

<p>LuaCwrap is a wrapper for C datatypes written in pure C. It utilizes metadata (aka type descriptors)
to describe the layout and names of structures, unions, arrays and buffers.</p>

<h2>Attention</h2>

<p>Because LuaCwrap allows to attach wrappers to existing userdata (pointers) it is not safe 
according to the Lua book. Common errors will be detected by LuaCwrap, but as the 'attach' 
method acts like a C cast many things could go wrong.
So if you use 'attach' be sure to know what you are doing.</p>

<h2>Features</h2>

<p>LuaCwrap</p>

<ul>
    <li>supports struct and union types</li>
    <li>supports array types</li>
    <li>supports fixed length buffers</li>
    <li>supports pointers</li>
    <li>lua strings and userdata could be assigned to wrapped pointers</li>
    <li>maintains lifetime of lua objects which had been assigned to wrapped pointers</li>
    <li>supports C and Lua API</li>
</ul>

<h1>Installation</h1>

<p>First download the source code via git </p>

<div class="code">git clone git://github.com/oberhofer/luacwrap.git master
</div>

<p>or unpack the package you got via the download option</p>

<h2>Linux</h2>

<h3>Prerequisites</h3>

<p>Install Lua and the development files we depend on</p>

<div class="code">sudo apt-get install liblua5.1-0 liblua5.1-0-dev
</div>

<h3>Build from source</h3>

<ul>
    <li>Start a console and change to the directory where the luacwrap source is located</li>
    <li>Start make
    make</li>
    <li>This creates two shared libraries (luacwrap.1.0.0.so and testluacwrap.1.0.0.so) within ./src
    The necessary links needed to execute the unittest.lua within ./src are also created.</li>
    <li>You can execute the unittests via
    make test</li>
</ul>

<h3>Installation</h3>

<p>Edit the makefile to set the correct destination directory for the library files
and execute</p>

<div class="code">sudo make install
</div>

<p>This creates the necessary libs/links within /usr/local/lib and /usr/local/lib/lua/5.1 to
enable LuaCwrap to be3 used as a shared library and a lua module.</p>


<h2>Windows</h2>

<h3>Prerequisites</h3>

<p>Install Lua for Windows from http://luaforwindows.googlecode.com/</p>

<h3>Build from source</h3>

<ul>
    <li><p>Edit ./etc/msvc.bat and set the correct path to the Lua for Windows header and library files.</p></li>
    <li><p>Open a Visual Studio .NET Command Prompt</p></li>
    <li><p>Change path to the luacwrap root directory</p></li>
    <li><p>Execute</p>
    
    <p>etc\msvc.bat</p></li>
</ul>

<p>As a result you should have now the files luacwrap.dll and testluacwrap.dll within your source directory.
To execute the unittest, do</p>

<div class="code">cd src
lua unittest.lua
</div>

<h3>Installation</h3>

<p>To install luacwrap into Lua for Windows copy the file luacwrap.dll to the Lua for Windows clibs directory.</p>

<h1>Usage</h1>

<h2>Dual interface</h2>

<p>The LuaCwrap exports several functions. One of them the luaopen_luacwrap
function enables that LuaCwrap could be used from standalone lua scripts.
The other functions could be bound to by lua C modules or executables
to be able to declare wrapped structs within C.</p>

<h2>Lua-API</h2>

<h3>Import LuaCwrap</h3>

<p>Importing LuaCwrap is only necessary if you want to declare your own types via the Lua-API.
In this case use the followig line:</p>

<div class="code">luacwrap = import("luacwrap")
</div>

<p>C modules which want to provide wrappers usually create their own namespace table to register their types. 
For an example see the source code of the <code>testluacwrap</code> module, which is provided with this package 
for unittesting.</p>

<h3>Registering type descriptors</h3>

<h4>Register array types</h4>

<div class="code">type = luacwrap.registerarraytype(name, size, elemtype)
</div>

<h4>Register record types</h4>

<div class="code">type = luacwrap.registerrecordtype(name, members)
</div>

<h4>Register buffer types</h4>

<div class="code">type, name = luacwrap.registerbuffertype(name, size)
</div>

<h3>Create/Attach instances</h3>

<p>Every registered type descriptor has two methods <code>new</code> and <code>attach</code> which could be used to
create new instances or create a wrapper around existing userdata.</p>

<div class="code">local struct = TESTSTRUCT:new()           -- create new garbage collected struct
local wrap = TESTSTRUCT:attach(udata)     -- attach descriptor to (light) user data
</div>

<h2>C-API</h2>

<h3>Registering type descriptors</h3>

<h4>Register array types</h4>

<div class="code">// describe array type
luacwrap_ArrayType regType_INT32_4 =
{
  LUACWRAP_TC_ARRAY,
  "INT32_4",
  4,
  sizeof(INT32),
  "$i32"
};

luacwrap_registertype(L, LUA_GLOBALSINDEX, &amp;regType_INT32_4.hdr);
</div>

<h4>Register record types</h4>

<div class="code">// member descriptor for INNERSTRUCT
static luacwrap_RecordMember s_memberINNERSTRUCT[] =
{
  { "pszText",  offsetof(INNERSTRUCT, pszText),  "$ptr" },
  { NULL, 0 }
};

// type descriptor for INNERSTRUCT
LUACWRAP_DEFINESTRUCT(LIBRARYNAME, INNERSTRUCT)

// register type within globals table
luacwrap_registertype(L, LUA_GLOBALSINDEX, &amp;regType_INNERSTRUCT.hdr);
</div>

<h4>Register buffer types</h4>

<div class="code">luacwrap_BasicType regType_Buf32 =
{
  LUACWRAP_TC_BUFFER,
  "$buf32",
  32
};

luacwrap_registerbasictype(L, &amp;regType_Buf32);
</div>

<h4>Register basic types</h4>

<p>For these types you have to specify appropriate get and set callbacks which handles
marshalling. Therefore registering basic types is only possible via the C API.
Use the <code>luacwrap_registerbasictype</code> function and see the source of LuaCwrap
for usage examples.</p>

<h3>Create/Attach instances</h3>

<p>From the C API in most cases you push wrappers to static instances to call functions
with parameters. </p>

<p>Attention: Wrappers are alive during the function call and not beyond.
It's definitely not a good idea to store them within the called function for later use.</p>

<div class="code">// static instance
TESTSTRUCT ud = { 0 };

// fill struct with data
ud.u8  =   8;
ud.i8  =  -8;
...

// call "myfunction" with wrapped object as parameter 1
lua_getglobal(L, "myfunction");

// push wrapper
luacwrap_pushtypedptr(L, &amp;regType_TESTSTRUCT.hdr, &amp;ud);

lua_call(L, 1, 0);
</div>


<h1>Internals</h1>


<h2>Module table _M</h2>

<p>LuaCwrap creates a single module table, where all module global data is stored.
The module table contains:</p>

<ul>
    <li>helper functions (e.g. tabletostring, getfield, setfield)</li>
    <li>register functions (registerbuffer, registerarray, registerstruct)</li>
    <li>buffer creation function (createbuffer)</li>
    <li>types table (_M.types)</li>
</ul>

<h2>Type descriptor table _M.types</h2>

<p>The type descriptor table spans the namespace for all registered types. Type names containing dots are
stored in the corresponding subtables.
The type table contains predefined types which names start with the '$' character. 
These are</p>

<ul>
    <li>$i8 , $u8  (signed/unsigned char)</li>
    <li>$i16, $u16 (signed/unsigned short)</li>
    <li>$i32, $u32 (signed/unsigned long)</li>
    <li>$flt, $dbl (float, double)</li>
    <li>$ptr       (pointer types)</li>
    <li>$ref       (reference type utilizing the lua reference mechanism)</li>
</ul>

<p>Buffers are registered within the type table, too. The name of buffer types is derived
from the buffer length ($buf*, where * denotes the buffer length).
If a buffer with the requested size is already registered, the existing one is returned.</p>

<h1>License</h1>

<p>LuaCwrap is licensed under the terms of the MIT license reproduced below.
This means that LuaCwrap is free software and can be used for both academic
and commercial purposes at absolutely no cost.</p>

<p>Copyright (C) 2011 Klaus Oberhofer</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</p>


</body></html>